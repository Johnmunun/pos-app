import{n as h,c as f}from"./app-DZtTOeIE.js";const b="pos-saas-offline",_=3,u="pending_products",y="pending_images",l="pending_categories",S="pending_settings";class v{constructor(){this.db=null,this.initPromise=null}async init(){return this.initPromise?this.initPromise:(this.initPromise=new Promise((t,e)=>{const s=indexedDB.open(b,_);s.onerror=()=>e(s.error),s.onsuccess=()=>{this.db=s.result,t(this.db)},s.onupgradeneeded=n=>{const o=n.target.result;if(!o.objectStoreNames.contains(u)){const r=o.createObjectStore(u,{keyPath:"id",autoIncrement:!1});r.createIndex("status","status",{unique:!1}),r.createIndex("created_at","created_at",{unique:!1})}if(o.objectStoreNames.contains(y)||o.createObjectStore(y,{keyPath:"product_id",unique:!0}).createIndex("status","status",{unique:!1}),!o.objectStoreNames.contains(l)){const r=o.createObjectStore(l,{keyPath:"id",autoIncrement:!1});r.createIndex("status","status",{unique:!1}),r.createIndex("created_at","created_at",{unique:!1})}if(!o.objectStoreNames.contains(S)){const r=o.createObjectStore(S,{keyPath:"id",autoIncrement:!0});r.createIndex("status","status",{unique:!1}),r.createIndex("created_at","created_at",{unique:!1})}}}),this.initPromise)}isOnline(){return navigator.onLine}async savePendingProduct(t,e=null){await this.init();const s=this.db.transaction([u,y],"readwrite"),n=s.objectStore(u),o=s.objectStore(y),r={id:t.id||`pending_${Date.now()}_${Math.random().toString(36).substr(2,9)}`,...t,status:"pending",created_at:new Date().toISOString(),synced:!1};if(await n.put(r),e){const a=await this.fileToBase64(e);await o.put({product_id:r.id,image:a,filename:e.name,mimeType:e.type,size:e.size,status:"pending",created_at:new Date().toISOString()})}return r.id}async getPendingProducts(){return await this.init(),new Promise((t,e)=>{const r=this.db.transaction([u],"readonly").objectStore(u).index("status").getAll("pending");r.onsuccess=()=>t(r.result),r.onerror=()=>e(r.error)})}async getPendingImage(t){return await this.init(),new Promise((e,s)=>{const r=this.db.transaction([y],"readonly").objectStore(y).get(t);r.onsuccess=()=>e(r.result),r.onerror=()=>s(r.error)})}async markProductSynced(t){await this.init();const e=this.db.transaction([u,y],"readwrite"),s=e.objectStore(u),n=e.objectStore(y),o=await new Promise((a,i)=>{const g=s.get(t);g.onsuccess=()=>a(g.result),g.onerror=()=>i(g.error)});o&&(o.status="synced",o.synced=!0,o.synced_at=new Date().toISOString(),await s.put(o));const r=await new Promise((a,i)=>{const g=n.get(t);g.onsuccess=()=>a(g.result),g.onerror=()=>i(g.error)});r&&(r.status="synced",r.synced_at=new Date().toISOString(),await n.put(r))}async removeSyncedProduct(t){await this.init();const e=this.db.transaction([u,y],"readwrite"),s=e.objectStore(u),n=e.objectStore(y);await s.delete(t),await n.delete(t)}fileToBase64(t){return new Promise((e,s)=>{const n=new FileReader;n.onload=()=>e(n.result),n.onerror=s,n.readAsDataURL(t)})}base64ToFile(t,e,s){const n=t.split(","),o=n[0].match(/:(.*?);/)[1],r=atob(n[1]);let a=r.length;const i=new Uint8Array(a);for(;a--;)i[a]=r.charCodeAt(a);return new File([i],e,{type:s||o})}async savePendingCategory(t){await this.init();const s=this.db.transaction([l],"readwrite").objectStore(l),n={id:t.id||`pending_${Date.now()}_${Math.random().toString(36).substr(2,9)}`,...t,status:"pending",created_at:t.created_at||new Date().toISOString(),synced:!1};return await s.put(n),n.id}async getPendingCategories(){return await this.init(),new Promise((t,e)=>{const r=this.db.transaction([l],"readonly").objectStore(l).index("status").getAll("pending");r.onsuccess=()=>t(r.result),r.onerror=()=>e(r.error)})}async markCategorySynced(t){await this.init();const s=this.db.transaction([l],"readwrite").objectStore(l),n=await new Promise((o,r)=>{const a=s.get(t);a.onsuccess=()=>o(a.result),a.onerror=()=>r(a.error)});n&&(n.status="synced",n.synced=!0,n.synced_at=new Date().toISOString(),await s.put(n))}async removeSyncedCategory(t){await this.init(),await this.db.transaction([l],"readwrite").objectStore(l).delete(t)}async savePendingSettings(t){await this.init();const s=this.db.transaction([S],"readwrite").objectStore(S),n={...t,status:"pending",created_at:new Date().toISOString(),synced:!1};return await s.put(n),n}async getPendingSettings(){await this.init();const s=this.db.transaction([S],"readonly").objectStore(S).index("status");return new Promise((n,o)=>{const r=s.getAll("pending");r.onsuccess=()=>n(r.result||[]),r.onerror=()=>o(r.error)})}async markSettingsSynced(t){await this.init();const s=this.db.transaction([S],"readwrite").objectStore(S),n=s.get(t);n.onsuccess=()=>{const o=n.result;o&&(o.status="synced",o.synced=!0,o.synced_at=new Date().toISOString(),s.put(o))}}async removeSyncedSettings(t){await this.init(),await this.db.transaction([S],"readwrite").objectStore(S).delete(t)}}const d=new v;class I{constructor(){this.isSyncing=!1,this.syncListeners=[],this.setupOnlineListener()}setupOnlineListener(){window.addEventListener("online",()=>{console.log("Connection restored, starting sync..."),this.syncPendingItems()}),navigator.onLine&&setTimeout(()=>{this.syncPendingItems()},2e3)}async syncPendingItems(){if(!(this.isSyncing||!navigator.onLine)){this.isSyncing=!0,this.notifyListeners({type:"sync_start"});try{const t=await d.getPendingProducts();let e=0,s=0;for(const c of t)try{await this.syncProduct(c),e++}catch(p){console.error("Error syncing product:",p),s++}for(const c of t)c.synced&&await d.removeSyncedProduct(c.id);const n=await d.getPendingCategories();let o=0,r=0;for(const c of n)try{await this.syncCategory(c),o++}catch(p){console.error("Error syncing category:",p),r++}for(const c of n)c.synced&&await d.removeSyncedCategory(c.id);const a=await d.getPendingSettings();let i=0,g=0;for(const c of a)try{await this.syncSettings(c),i++}catch(p){console.error("Error syncing settings:",p),g++}for(const c of a)c.synced&&await d.removeSyncedSettings(c.id);const m=e+o+i,w=s+r+g;if(m>0){const c=[];e>0&&c.push(`${e} produit(s)`),o>0&&c.push(`${o} catégorie(s)`),i>0&&c.push(`${i} paramètre(s)`),h.success(`${c.join(" et ")} synchronisé(s)`,{duration:3e3})}w>0&&h.error(`${w} erreur(s) lors de la synchronisation`,{duration:4e3}),this.notifyListeners({type:"sync_complete",synced:m,errors:w})}catch(t){console.error("Error during sync:",t),this.notifyListeners({type:"sync_error",error:t})}finally{this.isSyncing=!1}}}async syncProduct(t){const e=t.id,s=e.startsWith("pending_"),n=await d.getPendingImage(e),o=new FormData;if(Object.keys(t).forEach(i=>{if(i!=="id"&&i!=="status"&&i!=="created_at"&&i!=="synced"&&i!=="synced_at"){const g=t[i];g!=null&&o.append(i,g)}}),n&&n.image){const i=d.base64ToFile(n.image,n.filename,n.mimeType);o.append("image",i)}const r=s?route("pharmacy.products.store"):route("pharmacy.products.update",e.replace("pending_","")),a=s?"post":"put";try{const i=await f[a](r,o,{headers:{"Content-Type":"multipart/form-data"}});return await d.markProductSynced(e),i.data}catch(i){throw i.response?.status===422?new Error("Validation error: "+(i.response.data.message||"Invalid data")):i}}async syncNow(){if(!navigator.onLine){h.error("Vous devez être en ligne pour synchroniser");return}await this.syncPendingItems()}addSyncListener(t){this.syncListeners.push(t)}removeSyncListener(t){this.syncListeners=this.syncListeners.filter(e=>e!==t)}notifyListeners(t){this.syncListeners.forEach(e=>{try{e(t)}catch(s){console.error("Error in sync listener:",s)}})}async syncCategory(t){const e=t.id,s=e.startsWith("pending_"),n={name:t.name,description:t.description||"",parent_id:t.parent_id||null,sort_order:t.sort_order||0,is_active:t.is_active!==void 0?t.is_active:!0},o=s?route("pharmacy.categories.store"):route("pharmacy.categories.update",e.replace("pending_","")),r=s?"post":"put";try{const a=await f[r](o,n);return await d.markCategorySynced(e),a.data}catch(a){throw a.response?.status===422?new Error("Validation error: "+(a.response.data.message||"Invalid data")):a}}async syncPendingCategories(){if(navigator.onLine)try{const t=await d.getPendingCategories();for(const e of t)try{await this.syncCategory(e)}catch(s){console.error("Error syncing category:",s)}for(const e of t)e.synced&&await d.removeSyncedCategory(e.id)}catch(t){console.error("Error during category sync:",t)}}async syncPendingSettings(){if(navigator.onLine)try{const t=await d.getPendingSettings();let e=0,s=0;for(const n of t)try{await this.syncSettings(n),e++}catch(o){console.error("Error syncing settings:",o),s++}for(const n of t)n.synced&&await d.removeSyncedSettings(n.id);e>0&&h.success(`${e} paramètre(s) synchronisé(s)`)}catch(t){console.error("Error syncing pending settings:",t)}}async syncSettings(t){const e=new FormData;if(t.logo_base64){const n=d.base64ToFile(t.logo_base64,"logo.png","image/png");e.append("logo",n)}Object.keys(t).forEach(n=>{if(n!=="logo_base64"&&n!=="id"&&n!=="status"&&n!=="created_at"&&n!=="synced"&&n!=="synced_at"){const o=t[n];o!=null&&o!==""&&e.append(n,o)}});const s=await f.put(route("settings.update"),e,{headers:{"Content-Type":"multipart/form-data"}});if(s.status===200||s.status===204)return await d.markSettingsSynced(t.id),!0;throw new Error("Failed to sync settings")}async getSyncStatus(){const t=await d.getPendingProducts(),e=await d.getPendingCategories(),s=await d.getPendingSettings();return{isSyncing:this.isSyncing,pendingProducts:t.length,pendingCategories:e.length,pendingSettings:s.length,pendingCount:t.length+e.length+s.length,isOnline:navigator.onLine}}}const j=new I,O=Object.freeze(Object.defineProperty({__proto__:null,default:j},Symbol.toStringTag,{value:"Module"}));export{O as a,d as o,j as s};
